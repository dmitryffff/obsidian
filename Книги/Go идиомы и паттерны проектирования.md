---
tags:
  - книги
  - программирование
  - backend
  - programming_base
  - go
автор: Джон Боднер
год: 2025
начал читать: 2024-12-31
закончил читать: 
количество страниц: 411
оценка(0/10): 
прочитал n-раз: 
цена: 1500
---

### Резюме
==Добавьте краткие итоги и свои впечатления о книге. Что нового вы узнали и какие ее особенности?==

## 1. Настройка среды разработки
1. В go из коробки идет форматтер, который имеет строгие дефолтные стили, которые нельзя поменять. Это нужно для оптимизации компилятора, разрешения споров по поводу стиля, удобства разработки.
2. `go run hello.go` – компилирует программу, запускает ее, но не сохраняет бинарник
3. `go build hello.go` – компилирует программу и сохраняет бинарник в текущей директирии
4. Для билда go-кода нужно устанавливать язык на устройство, для запуска скомпилированной программы нужен только сам бинарный файл программы и ничего кроме
5. make-файлы позволяют выполнять определенные шаги, а не запускать отдельную команду `make`(`make lint` – для запуска конкретной цели):
```yml
# команда build будет выполняться по-умолчаю, если не указан шаг(цель)
.DEFAULT_GOAL=build

# "fmt" – название шага
fmt:
	go fmt ./...
.PHONY:fmt

# "lint" – название шага,
# "fmt" – шаг, который должен выполниться перед запуском "lint"
lint: fmt
	golint ./...
.PHONY:lint

vet: fmt
	go vet ./...
.PHONY:vet

build: vet
	go build hello.go
.PHONY:build
```

## 2. Простые типы и объявление переменных

1. Нулевое значение –  присваивается по-дефолту любой переменной, которая была объявлена, но не была инициализирована
2. Литералы:
	1. Целочисленные – числа с основанием 10, 2`0b`, 8`0o`, 16`0x`, можно разделять числа `1_2_3`, но лучше использовать для разделения разрядов тысяч `1_024`
	2. С плавающей запятой – содержит запятую, отделяющую дробную часть значения, можно возводить в степень `3,14e3`, можно записывать в 16-м виде с префиксом `0x` и разделителем степени `p`
	3. Руны – символы, **заключаются в одинарные(`''`) кавычки**
	   *в go одинарные и двойные кавычки не являются взаимозаменяемыми*
	4. Строки – последовательносьт символов
		1. **интерпретируемый** строковый литерал(`""`) – `"Hello, World!"`, можно экранировать, вставлять новые строки `"Hello,\n\"World!\""`
		2. **необработанный** строковый литерал(\`) – \`Hello,<перенос строки>Wordl!\`
3. Литералы в go являются нетипизированными, по типу `1` – литерал целого числа, а его тип `int64`, `int32` и т.д. определяется уже в месте использования
4. Логические(`bool`) – `true`, `false`
   *нулевое значение  – `false`*
```go
var flag bool // по-умолчанию false
var isAwesome = true
```
5. Числовые типы – `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`
   *нулевое значение для числовых типов – `0`*
	1. `byte` – псевдоним типа `uint8`\[0, 255\], **стоит использовать именно `byte`**
	2. `int`/`uint` – в 64-х разрядной ОС это `int64`, в 32-х разрядной ОС это `int32`, поэтому **НЕЛЬЗЯ напрямую взаимодействовать между `int`, `int32`, `int64`** – нужно явно приводить типы
	   *`int` является целочисленным типо по-умолчанию*
	3. `rune` – псевдоним типа `int32`, используется для представления кодовой точки Unicode
	4. `uintptr` – ***ДОПИСАТЬ***
6. Какой целочисленный тип использовать?
	1. Если работаем с файлами двоичного формата или сетевыми протоколами – используем их разрядность
	2. Если пишем библиотечные функции, может потребоваться написать миниму две функции для `int64` и `uint64`, максимум – для всех типов
	3. В других случаях просто используем `int`, иначе будет считаться преждевременной оптимизацией
7. Типы с плавающей запятой – `float64`, `float32`
   *по-умолчанию `float32`*
	1. По поводу использования памяти можно не заморачиваться, пока не скажет профайлер
	2. Числа с плавающей запятой являются НЕТОЧНЫМИ, т.к. имеют ограниченное число знаков после запятой и не могут отразить все значения, могут только приблизительные
	3. ЕСЛИ ВАЖНА ТОЧНОСТЬ – НЕ ИСПОЛЬЗУЕМ ЧИСЛА С ПЛАВАЮЩЕЙ ЗАПЯТОЙ
	4. Из-за примерного представления числа два, казалось бы, одинакового числа могут быть не равны
8.  В go НЕТ автоматического повышения типов числа(например, с  `int32` до `int64`), мы должны ЯВНО их преобразовывать
```go
var a int = 10
var b float64 = 3.14
var c = float64(a) * b
var d = a + int(b)
```
9. ВСЕ преобразования типов в go выполняются ЯВНЫМ образом
   ***ни один тип не может быть явно или неявно преобразован в логический**, для этого нужно использовать операторы сравнения*
```go
var a = 0
var b = ""
// неправильно, надо явно if a != 0
if a {
	...
}

// неправильно, надо явно if b != ""
if b {
	...
}
```
 ***Определение переменной***
10. `var` с типом:
```go
var x int = 1
```
11. `var`  без типа, если устраивает тип по-умолчанию:
```go
var x = 1 // int
```
12. `var` с типо без значения, если хотим явно задать переменной нулевое значение определенного типа:
```go
var x int // 0
var y string // ""
var z bool // false
```
13. `var` с объявлением нескольких переменных:
```go
var a, b int = 1, "str"
var c, d int // 0, 0
var x, y = 1, "str"
```
14. `var` с списком объявлений:
```go
var (
x int
y = 20
z int = 30
d, e = 1, "hello"
f, g string // "", ""
)
```
15. `var` НЕ может переопределить уже существующую переменную
```go
var a = 10
var a = 20 // a redeclared in this block, other declaration of a
```
17. `:=` – **только внутри функций**)
```go
x := 10
y, z := 10, "hello"
```
18. `:=` – МОЖЕТ ПЕРЕОПРЕДЕЛИТЬ уже существующую переменную, ЕСЛИ переопределяем **+** создаем новую переменную:
```go
x := 10
x, y := 20, 30
y := 40 // no new variables on left side of :=
```
19. `:=` – **нельзя использовать вне функции**
20. `const` – позволяют определить неизменяемые значения
    *по сути, просто способ присвоения имен литералам*
```go
const x int64 = 10
const (
	idKey = "id"
	nameKey = "name"
)
const z = 10 * 20
```
21. `const` позволяет использовать только значения, вычисляемые на этапе компиляци, поэтому нельзя определять ничего кроме: числовых, строковых, булевых литералов, рун, а так же встроенных функций complex, real, imag, len, cap + вычисляемые с операторами(+, - и т.д.)
    *в go НЕЛЬЗЯ сделать массив, срез, свойство структуры неизменяемым*
22. для всех переменных/констант используется `camelCase`
## 3. Составные типы
1. Массив – структура данных **фиксированной длины**:
```go
var a [3]int // массив из 3-х элементов, каждый элемента типа int; т.к. не указали значения, будет массив из нужевых значений типа int {0, 0, 0}
var b = [3]int{10, 20, 30}
var c = [12]int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
var d = [...]int{10, 20, 30} // если сразу добавляем значения – можем не указывать размерность, а использовать(ОБЯЗАТЕЛЬНО) `...`
```
2. Для сравнения массивов используем `==`, `!=`:
```go
var a = [3]int{10, 20, 30}
var b = [...]int{10, 20, 30}
fmt.Print(a == b) // true
```
3. Чтение/запись происходит через `a[0] = 10`, `fmt.Print(a[2])`
	1. Если длина массива ***заранее известна***(задана с помощью константы/литерала), то при выходе за границы массива получим ошибку компиляции
	2. Если длина массива ***определяется на этапе выполнения***, то код скомпилируется, но при выходе за границы выдаст панику
4. ***ДЛИНА МАССИВА ЯВЛЯЕТСЯ ЧАСТЬЮ ЕГО ТИПА***, т.е. `[3]int` и `[4]int` имеют разный тип. Из этого следует:
	1. Не можем использовать **переменную** для создания типа, т.к. для создания типа на этапе компиляции должна быть известна размерность массива
	2. ***Нельзя преобразовать массив одного типа, в массив другого типа***
	   Итог: нельзя написать функцию, обрабатывающую разные массивы
5. ***МАССИВЫ СТОИТ ИСПОЛЬЗОВАТЬ ТОЛЬКО ТОГДА, КОГДА ЗАРАНЕЕ ИЗВЕСТНА ЕГО ДЛИНА***
6. ***СРЕЗ – переменная длина; длина не является составной частью типа***
```go
var a = []int{10, 20, 30} // как массив, но НЕ указываем длину
var c = []int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
```
7. ***Нулевое значение среза – `nil`:***
   *`nil` не `null`; о `nil` позже, в главе 6*
```go
var a []int // НЕ пустой срез, а nil
```
8. Срез является не сравниваемым, можно только проверить на равенство/неравенство `nil`:
```go
var a []int
fmt.Print(a == nil) // true
var b = []int{1, 3}
fmt.Print(a == b) // invalid operation: a == b (slice can only be compared to nil)
```
10. Встроенная функция `len` – возвращает длину массива/среза 
    *в go нельзя самому написать функции, подобные `len`*
```go
var a = []int{10, 20, 30}
fmt.Print(len(a)) // 3

var b []int // nil
fnt.Print(len(b)) // 0
```
11.  Встроенная функция `append` – позволяет добавлять новые элементы в массив:
    *в go аргументы в функции передаются по-значению, т.е. каждый раз при вызове ф-ии передается не само значение, а его копия, `append` добавляет новый элемент в копию и возвращает новый срез, который нужно присвоить – иначе будет ошибка*
```go
var x []int
// ❗обязательно надо присвоить результат выполнения функции append тому же массиву❗
x = append(x, 10)
x = append(x, 20, 30, 40)
append(x, 50) // append(x, 50) (value of type []int) is not used
```
12. Емкость среза – количество зарезервированной памяти для массива. Например, у нас есть срез с длинной 5. Но его емкость может быть больше для возможности добавления новых элементов без копирования и перемещения данных.
    *Массив – структура данных, в которой все элементы находятся рядом друг за другом. Go автоматически увеличивает емкость массива по мере добавления туда новых элементов и переноса массива.*
```go
// ячейки памяти
// [10][20][30][40][50][][] [другие][данные] – длина 5, но у нас на 2 ячейки памяти больше, чтобы могли добавить еще 2 элемента
var a = []int{10, 20, 30, 40, 50}
a = append(a, 60, 70)
// [10][20][30][40][50][60][70] [другие][данные]
a = append(a, 80) // при добавлении нового элемента go должен будет перенести массив в новое место
// [10][20][30][40][50][60][70] 80 [другие][данные] – не можем добавить, т.к. больше нет сместа по-соседству => надо переместить массив в другое место


var c = cap(a) // 8, для определения емкости массива
```
13. `make` – встроенная функция, позволяющая определить срез типа с размером(длиной) и емкостью(опционально):
    *значение емкости не может быть меньше значения длины*
```go
var a = make([]int, 3) // [0][0][0]
var b = make([]string, 4, 7) // [""][""][""][""][][][]
// append всегда увеличивает длину среза
b = append(b, "5", "6") // [""][""][""][""]["5"]["6"][]

// функция make([]int, 3) создает не nil, а массив определенной длины с нулевыми значениями типа среза []int{0, 0, 0}, т.е.
var c = make([]int) // []int{}
var d []int // nil
fmt.Print(c == d) // false
```
14. Можно срезать срезы:
```go
var a = []int{10, 20, 30, 40, 50, 60}
var b = a[1:3] // [20, 30]
var c = a[:4] // [10, 20, 30, 40]
var d = a[2:] // [40, 50, 60]
```
15. Срезы используют ту же область памяти, что и изначальный массив, т.е. если изменить изначальный срез или один из его срезов, то изменятся все связанные срезы:
    *длина у подсреза, а емкость как у основного массива `-` сдвиг начала*
```go
var a = []int{10, 20, 30, 40} // 0[10]1[20]2[30]3[40], len 4, cap 4
var b = a[:2] // 0[10]1[20], len 2, cap 4
var c = a[1:] // 1[20]2[30]3[40], len 3, cap 3
a[1] = 2
b[0] = 1
c[1] = 3
// a, b, c: [1][2][3][40], [1][2], [2][3][40]
```
16. КРАЙНЕ НЕЖЕЛАТЕЛЬНО использовать `append` вместе со срезами срезов, лучше вообще не изменять срезы после их срезания
17. Можно срезать массивы – получится срез:
```go
var a = [4]int{1, 2, 3, 4}
var b = a[:2] // []int{1, 2}
var c = a[:] // []int{1, 2, 3, 4} – по сути копируем массив в срез
```