---
tags:
  - книги
  - программирование
  - backend
  - programming_base
  - go
автор: Джон Боднер
год: 2025
начал читать: 2024-12-31
закончил читать: 
количество страниц: 411
оценка(0/10): 
прочитал n-раз: 
цена: 1500
---

### Резюме
==Добавьте краткие итоги и свои впечатления о книге. Что нового вы узнали и какие ее особенности?==

## 1. Настройка среды разработки
1. В go из коробки идет форматтер, который имеет строгие дефолтные стили, которые нельзя поменять. Это нужно для оптимизации компилятора, разрешения споров по поводу стиля, удобства разработки.
2. `go run hello.go` – компилирует программу, запускает ее, но не сохраняет бинарник
3. `go build hello.go` – компилирует программу и сохраняет бинарник в текущей директирии
4. Для билда go-кода нужно устанавливать язык на устройство, для запуска скомпилированной программы нужен только сам бинарный файл программы и ничего кроме
5. make-файлы позволяют выполнять определенные шаги, а не запускать отдельную команду `make`(`make lint` – для запуска конкретной цели):
```yml
# команда build будет выполняться по-умолчаю, если не указан шаг(цель)
.DEFAULT_GOAL=build

# "fmt" – название шага
fmt:
	go fmt ./...
.PHONY:fmt

# "lint" – название шага,
# "fmt" – шаг, который должен выполниться перед запуском "lint"
lint: fmt
	golint ./...
.PHONY:lint

vet: fmt
	go vet ./...
.PHONY:vet

build: vet
	go build hello.go
.PHONY:build
```

## 2. Простые типы и объявление переменных

1. Нулевое значение –  присваивается по-дефолту любой переменной, которая была объявлена, но не была инициализирована
2. Литералы:
	1. Целочисленные – числа с основанием 10, 2`0b`, 8`0o`, 16`0x`, можно разделять числа `1_2_3`, но лучше использовать для разделения разрядов тысяч `1_024`
	2. С плавающей запятой – содержит запятую, отделяющую дробную часть значения, можно возводить в степень `3,14e3`, можно записывать в 16-м виде с префиксом `0x` и разделителем степени `p`
	3. Руны – символы, **заключаются в одинарные(`''`) кавычки**
	   *в go одинарные и двойные кавычки не являются взаимозаменяемыми*
	4. Строки – последовательность символов
		1. **интерпретируемый** строковый литерал(`""`) – `"Hello, World!"`, можно экранировать, вставлять новые строки `"Hello,\n\"World!\""`
		2. **необработанный** строковый литерал(\`) – \`Hello,<перенос строки>Wordl!\`
3. Литералы в go являются нетипизированными, по типу `1` – литерал целого числа, а его тип `int64`, `int32` и т.д. определяется уже в месте использования
4. Логические(`bool`) – `true`, `false`
   *нулевое значение  – `false`*
```go
var flag bool // по-умолчанию false
var isAwesome = true
```
5. Числовые типы – `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`
   *нулевое значение для числовых типов – `0`*
	1. `byte` – псевдоним типа `uint8`\[0, 255\], **стоит использовать именно `byte`**
	2. `int`/`uint` – в 64-х разрядной ОС это `int64`, в 32-х разрядной ОС это `int32`, поэтому **НЕЛЬЗЯ напрямую взаимодействовать между `int`, `int32`, `int64`** – нужно явно приводить типы
	   *`int` является целочисленным типо по-умолчанию*
	3. `rune` – псевдоним типа `int32`, используется для представления кодовой точки Unicode
	4. `uintptr` – ***ДОПИСАТЬ***
6. Какой целочисленный тип использовать?
	1. Если работаем с файлами двоичного формата или сетевыми протоколами – используем их разрядность
	2. Если пишем библиотечные функции, может потребоваться написать миниму две функции для `int64` и `uint64`, максимум – для всех типов
	3. В других случаях просто используем `int`, иначе будет считаться преждевременной оптимизацией
7. Типы с плавающей запятой – `float64`, `float32`
   *по-умолчанию `float32`*
	1. По поводу использования памяти можно не заморачиваться, пока не скажет профайлер
	2. Числа с плавающей запятой являются НЕТОЧНЫМИ, т.к. имеют ограниченное число знаков после запятой и не могут отразить все значения, могут только приблизительные
	3. ЕСЛИ ВАЖНА ТОЧНОСТЬ – НЕ ИСПОЛЬЗУЕМ ЧИСЛА С ПЛАВАЮЩЕЙ ЗАПЯТОЙ
	4. Из-за примерного представления числа два, казалось бы, одинакового числа могут быть не равны
8.  В go НЕТ автоматического повышения типов числа(например, с  `int32` до `int64`), мы должны ЯВНО их преобразовывать
```go
var a int = 10
var b float64 = 3.14
var c = float64(a) * b
var d = a + int(b)
```
9. ВСЕ преобразования типов в go выполняются ЯВНЫМ образом
   ***ни один тип не может быть явно или неявно преобразован в логический**, для этого нужно использовать операторы сравнения*
```go
var a = 0
var b = ""
// неправильно, надо явно if a != 0
if a {
	...
}

// неправильно, надо явно if b != ""
if b {
	...
}
```
 ***Определение переменной***
10. `var` с типом:
```go
var x int = 1
```
11. `var`  без типа, если устраивает тип по-умолчанию:
```go
var x = 1 // int
```
12. `var` с типо без значения, если хотим явно задать переменной нулевое значение определенного типа:
```go
var x int // 0
var y string // ""
var z bool // false
```
13. `var` с объявлением нескольких переменных:
```go
var a, b int = 1, "str"
var c, d int // 0, 0
var x, y = 1, "str"
```
14. `var` с списком объявлений:
```go
var (
x int
y = 20
z int = 30
d, e = 1, "hello"
f, g string // "", ""
)
```
15. `var` НЕ может переопределить уже существующую переменную
```go
var a = 10
var a = 20 // a redeclared in this block, other declaration of a
```
17. `:=` – **только внутри функций**)
```go
x := 10
y, z := 10, "hello"
```
18. `:=` – МОЖЕТ ПЕРЕОПРЕДЕЛИТЬ уже существующую переменную, ЕСЛИ переопределяем **+** создаем новую переменную:
```go
x := 10
x, y := 20, 30
y := 40 // no new variables on left side of :=
```
19. `:=` – **нельзя использовать вне функции**
20. `const` – позволяют определить неизменяемые значения
    *по сути, просто способ присвоения имен литералам*
```go
const x int64 = 10
const (
	idKey = "id"
	nameKey = "name"
)
const z = 10 * 20
```
21. `const` позволяет использовать только значения, вычисляемые на этапе компиляци, поэтому нельзя определять ничего кроме: числовых, строковых, булевых литералов, рун, а так же встроенных функций complex, real, imag, len, cap + вычисляемые с операторами(+, - и т.д.)
    *в go НЕЛЬЗЯ сделать массив, срез, свойство структуры неизменяемым*
22. для всех переменных/констант используется `camelCase`
## 3. Составные типы
1. Массив – структура данных **фиксированной длины**:
```go
var a [3]int // массив из 3-х элементов, каждый элемента типа int; т.к. не указали значения, будет массив из нужевых значений типа int {0, 0, 0}
var b = [3]int{10, 20, 30}
var c = [12]int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
var d = [...]int{10, 20, 30} // если сразу добавляем значения – можем не указывать размерность, а использовать(ОБЯЗАТЕЛЬНО) `...`
```
2. Для сравнения массивов используем `==`, `!=`:
```go
var a = [3]int{10, 20, 30}
var b = [...]int{10, 20, 30}
fmt.Print(a == b) // true
```
3. Чтение/запись происходит через `a[0] = 10`, `fmt.Print(a[2])`
	1. Если длина массива ***заранее известна***(задана с помощью константы/литерала), то при выходе за границы массива получим ошибку компиляции
	2. Если длина массива ***определяется на этапе выполнения***, то код скомпилируется, но при выходе за границы выдаст панику
4. ***ДЛИНА МАССИВА ЯВЛЯЕТСЯ ЧАСТЬЮ ЕГО ТИПА***, т.е. `[3]int` и `[4]int` имеют разный тип. Из этого следует:
	1. Не можем использовать **переменную** для создания типа, т.к. для создания типа на этапе компиляции должна быть известна размерность массива
	2. ***Нельзя преобразовать массив одного типа, в массив другого типа***
	   Итог: нельзя написать функцию, обрабатывающую разные массивы
5. ***МАССИВЫ СТОИТ ИСПОЛЬЗОВАТЬ ТОЛЬКО ТОГДА, КОГДА ЗАРАНЕЕ ИЗВЕСТНА ЕГО ДЛИНА***
6. ***СРЕЗ – переменная длина; длина не является составной частью типа***
```go
var a = []int{10, 20, 30} // как массив, но НЕ указываем длину
var c = []int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
```
7. ***Нулевое значение среза – `nil`:***
   *`nil` не `null`; о `nil` позже, в главе 6*
```go
var a []int // НЕ пустой срез, а nil
```
8. Срез является не сравниваемым, можно только проверить на равенство/неравенство `nil`:
```go
var a []int
fmt.Print(a == nil) // true
var b = []int{1, 3}
fmt.Print(a == b) // invalid operation: a == b (slice can only be compared to nil)
```
10. `len: func len(v Type) int` – встроенная функция, возвращает длину массива/среза 
    *в go нельзя самому написать функции, подобные `len`*
```go
var a = []int{10, 20, 30}
fmt.Print(len(a)) // 3

var b []int // nil
fnt.Print(len(b)) // 0
```
11. `append: func append(slice []Type, elems ...Type) []Type` – встроенная функция, позволяет добавлять новые элементы в массив:
    *в go аргументы в функции передаются по-значению, т.е. каждый раз при вызове ф-ии передается не само значение, а его копия, `append` добавляет новый элемент в копию и возвращает новый срез, который нужно присвоить – иначе будет ошибка*
```go
var x []int
// ❗обязательно надо присвоить результат выполнения функции append тому же массиву❗
x = append(x, 10)
x = append(x, 20, 30, 40)
append(x, 50) // append(x, 50) (value of type []int) is not used
```
12. Емкость среза – количество зарезервированной памяти для массива. Например, у нас есть срез с длинной 5. Но его емкость может быть больше для возможности добавления новых элементов без копирования и перемещения данных.
    *Массив – структура данных, в которой все элементы находятся рядом друг за другом. Go автоматически увеличивает емкость массива по мере добавления туда новых элементов и переноса массива.*
```go
// ячейки памяти
// [10][20][30][40][50][][] [другие][данные] – длина 5, но у нас на 2 ячейки памяти больше, чтобы могли добавить еще 2 элемента
var a = []int{10, 20, 30, 40, 50}
a = append(a, 60, 70)
// [10][20][30][40][50][60][70] [другие][данные]
a = append(a, 80) // при добавлении нового элемента go должен будет перенести массив в новое место
// [10][20][30][40][50][60][70] 80 [другие][данные] – не можем добавить, т.к. больше нет сместа по-соседству => надо переместить массив в другое место


var c = cap(a) // 8, для определения емкости массива
```
13. `make: func make(t Type, size ...IntegerType) Type` – встроенная функция, позволяющая определить срез типа с размером(длиной) и емкостью(опционально):
    *значение емкости не может быть меньше значения длины*
```go
var a = make([]int, 3) // [0][0][0]
var b = make([]string, 4, 7) // [""][""][""][""][][][]
// append всегда увеличивает длину среза
b = append(b, "5", "6") // [""][""][""][""]["5"]["6"][]

// функция make([]int, 3) создает не nil, а массив определенной длины с нулевыми значениями типа среза []int{0, 0, 0}, т.е.
var c = make([]int) // []int{}
var d []int // nil
fmt.Print(c == d) // false
```
14. Можно срезать срезы `a[индекс начала:индекс конца]`:
```go
var a = []int{10, 20, 30, 40, 50, 60}
var b = a[1:3] // [20, 30]
var c = a[:4] // [10, 20, 30, 40]
var d = a[2:] // [40, 50, 60]
var e = a[:10] // panic: runtime error: slice bounds out of range [:10] with capacity 6
```
15. Срезы используют ту же область памяти, что и изначальный массив, т.е. если изменить изначальный срез или один из его срезов, то изменятся все связанные срезы:
    *длина у подсреза, а емкость = `емкость основного массива - сдвиг начала`*
```go
var a = []int{10, 20, 30, 40} // 0[10]1[20]2[30]3[40], len 4, cap 4
var b = a[:2] // 0[10]1[20], len 2, cap 4
var c = a[1:] // 1[20]2[30]3[40], len 3, cap 3
a[1] = 2
b[0] = 1
c[1] = 3
// a, b, c: [1][2][3][40], [1][2], [2][3][40]
```
16. КРАЙНЕ НЕЖЕЛАТЕЛЬНО использовать `append` вместе со срезами срезов, лучше вообще не изменять срезы после их срезания
17. Можно срезать массивы – получится срез:
```go
var a = [4]int{1, 2, 3, 4}
var b = a[:2] // []int{1, 2}
var c = a[:] // []int{1, 2, 3, 4} – по сути делам срез из массива
```
18. `copy: func copy(dst, src []Type) int` – встроенная функция, которая позволяет скопировать срез **С ОТДЕЛЬНОЙ** областью памяти, отличной от области памяти базового среза:
    *возвращает количество скопированных элементов, которое можно игнорировать*
```go
var a = []int{1, 2, 3, 4, 5}
var b = make([]int, 4)
var c = copy(b, a) // 4 – было скопировано 4 элемента, т.к. длина слайса b – 4
fmt.Print(b) // [1, 2, 3, 4] нет последнего элемента(5), т.к. длина слайса b – 4
b[0] = 10

fmt.Print(b) // [10, 2, 3, 4, 5] – первый элемент изменился
fmt.Print(a) // [1, 2, 3, 4] – первый элемент НЕ изменился, т.к. теперь a и b – разные области памяти

------- Противопоставление со срезом
var a = []int{1, 2, 3, 4}
var b = make([]int, 4)
b = a[:]
fmt.Print(b) // [1, 2, 3, 4]
b[0] = 10

fmt.Print(b) // [10, 2, 3, 4] – первый элемент изменился
fmt.Print(a) // [10, 2, 3, 4] – первый элемент ТОЖЕ ИЗМЕНИЛСЯ, т.к. a и b используют одну область памяти
-------

var e = []int{1, 2, 3, 4, 5}
var f = make([]int, 2)
copy(f, e[2:])
fmt.Print(f) // [3, 4]

var g = [7]int{10, 20, 30, 40, 50, 60, 70}
copy(g[2:4], e[3:]) // можем копировать в определенные индексы таргет среза(массива)
fmt.Print(g) // [10, 20, 4, 5, 50, 60, 70]
```
19. Строка в go состоит из неизменяемой последовательности `byte`
20. Со строками можно использовать доступ по индексу, срезы, получение длины:
```go
var a = "Hello there"
var b byte = a[6] // t
var c string = a[:5] // "Hello"
var d string = a[5:6] // " "
var e string = a[7:] // "there"
var f = len(a) // 11
```
21. Строки состоят из символов UTF-8, длина одного символа может быть от 1 до 4 байт, следовательно, если длина символа более 1-го байта, то взятие слайса, получение символа по индексу, получение длины может быть ошибочным:
```go
var a = "Hello ☼"
var b byte = a[0] // H – все окей, т.к. длина символа H – 1 байт
var c string = a[:5] // "Hello" – тут тоже все окей, т.к. размер символов английского алфавита – 1 байт
var d byte = a[7] // ?? – непонятный символ, т.к. мы взяли только первый(из 3-х) байт символа ☼
var e string = a[7:] // "☼" – взяли все байты символа ☼
var f = len(e) // 3 – длина символа ☼
var g = len(a) // 9, а не 7, т.к. длина символа ☼ равна 3
```
22. Для извлечения из строк подстрок или кодовых точек нужно использова встроенную библиотеку `strings` или `unicode/utf8`
23. Карты `map` – соединяет ключи и значения `map[тип_ключа]тип_значения`:
    *нулевое значение `nil`; карты в go реализованы при помощи [хэш-таблиц](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)*
```go
var a map[string]int // nil
var b map[string]string // nil
fmt.Println(len(a)) // 0

// ❗можно читать значения у нулевого map – всегда будет возвращать нулевой тип значения❗
fmt.Println(a["a_key_1"]) // 0 – нулевое значение типа int
fmt.Println(b["b_key_1"]) // "" – нулевое значение типа string

// ❗нельзя записывать значения в nil-карту❗
a["a_key_1"] = 1 // panic: assignment to entry in nil map

var c = map[string]int{} // map[string]int{} – пустой 
fmt.Println(len(c)) // 0

// ❗можно читать значения у пустого литерала карты – всегда будет возвращать нулевой тип значения❗
fmt.Println(с["с_key_1"]) // 0

// ❗можно записывать значения в пустой литерал карты❗
с["с_key_1"] = 1
fmt.Println(с["с_key_1"]) // 1

var d = make(map[string]int, 2) // пустой литерал карты длиной 2
d["d_key_1"] = 1
d["d_key_2"] = 2
// можно добавлять значения сверх длины карты – она увеличится автоматически
d["d_key_3"] = 3
d["d_key_3"]++
fmt.Println(d["d_key_3"]) // 4

var e = map[string][]string{
	"key1": []string{"a", "b", "c"},
	"key2": []string{"d", "e", "f"},
	"key3": []string{"j", "h", "k"},
}
e["key1"] // nil
```
24. Идиома "запятая-ok" – позволяет определить, была пара ключ-значение задана или же нам вернулось нулевое значение типа значения:
```go
var a = map[string]int{
	"key_1": 1,
	"key_2": 2,
}
v, ok := a["key_1"] // "key_1" содержится в карте "a", поэтому v == 1, "ok" == true, 
v, ok := a["key_3"] // "key_3" НЕ содержится в карте "a", поэтому v == 0, "ok" == false
```
25. `delete: func delete(m map[Type]Type1, key Type)` – встроенная функция, позволяющая удалить пару ключ-значение из карты по ключу:
```go
var a = map[string]int{
	"key_1": 1
}
delete(a, "key_1")
```
26. Карта в качестве множества `set` – позволяет хранить только уникальные значения:
    *в go нет реализации `set` из коробки*
```go
// bool занимает 1 байт памяти
var intSet = map[int]bool{}
var vals = []int{1, 1, 1, 2, 3, 4, 4, 5, 6, 6, 6}
for _, v := range vals {
	intSet[v] = true
}
fmt.Println(intSet) // {1:true,2:true,3:true,4:true,5:true,6:true,} – только уникальные значения

// можно использовать пустую структуру struct{} – занимает 0 байт => более эффективно, НО для проверки надо будет использовать идиому запятая-ok
var intSet2 = map[int]struct{}{}
var vals = []int{1, 1, 1, 2, 3, 4, 4, 5, 6, 6, 6}
for _, v := range vals {
	intSet2[v] = struct{}
}
fmt.Println(intSet2) // {1:struct{},2:struct{},3:struct{},4:struct{},5:struct{},6:struct{},} – только уникальные значения
```
27. ***Структуры*** – позволяет определить определенный вид данных с конкретными ключами и их значениями:
	*НУЛЕВОЕ ЗНАЧЕНИЕ – СТРУКТУРА, ВСЕ ПОЛЯ КОТОРОЙ ИМЕЮ НУЛЕВЫЕ ЗНАЧЕНИЯ ТИПА ПОЛЯ*
    *карты не позволяют задать определенные ключи, а так же позволяют использовать только один тип в качестве значения*
```go
// Можно определять структуры на уровне модуля
type person struct {
	name string
	age int
	pet string
}

var p person // person{ name: "", age: 0, pet: "" }

// Можно внутри функции
func foo() {
	type fooPerson struct {
		firstName string
		lastName string
	}

	// Тип, объявленный в функции можно использовать только в ней(или ниже)
	fp := fooPerson{} // fooPerson { firstName: "", lastName: "" }
}

// Можно создавать экземпляры структуру без указания названия полей, НО все ЗНАЧЕНИЯ полей должны быть В ТОМ ЖЕ ПОРЯДКЕ КАК БЫЛИ ОБЪЯВЛЕНЫ В ТИПЕ СТРУКТУРЫ
var p1 = person {
	"Dima",
	24,
	"cat",
} // person{name:"Dima",age:24,pet:"cat",}

// Можно создавать экземпляр с указанием имени полей, тогда можно указывать в произвольном порядке – предпочтительный вариант создания
var p2 = person {
	age 21,
	pet "rat",
	name "Kate",
} // person{name:"Kate",age:21,pet:"rat"}

// Для доступа используется точечная нотация
p.name = "Dima"
p.age = 24
p.pet = "cat"
fmt.Println(p.name) // "Dima"
```
28. ***Анонимные структуры*** – позволяют определить тип структуры прямо во время инициализации переменной:
```go
var p = struct {
	name string
	age int
	pet string
}{
	name: "Dima",
	age: 24,
	pet: "cat",
}

var a = []struct {
	value string
}{
	{ value: "1" },
	{ value: "2" },
}
```
29. Сравнение структур:
	1. Если все значения структуры сравниваемые – то и сама структура сравнимаемая
	2. Если есть хотя бы одно несравниваемое, например, слайс – то и сама структура несравниваемая
30. В go НЕЛЬЗЯ СРАВНИВАТЬ ЗНАЧЕНИЯ РАЗНЫХ ТИПОВ, поэтому даже если есть две одинаковые структуры, то напрямую значения сравнить нельзя. Для сравнения нужно **преобразовать** один тип в другой, **если у типов идентичные названия полей, их значения, а так же порядок**:
```go
type firstPerson struct {
	firstName string
	lastName string
}

type secondPerson struct {
	firstName string
	lastName string
}

type thirdPerson struct {
	firstName string
	lastName string
	age int
}

type fourthPerson struct {
	lastName string
	firstName string
}

var p1 = firstPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}

var p2 = secondPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}

var p3 = thirdPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
	age: 24,
}

var p4 = fourthPerson {
	lastName: "Fominenkov",
	firstName: "Dima",
}

fmt.Println(p1 == p2) // invalid operation: p1 == p2 (mismatched types firstPerson and secondPerson)
fmt.Println(p1 == firstPerson(p2)) // true
fmt.Println(p1 == firstPerson(p3)) // cannot convert p3 (variable of type thirdPerson) to type firstPerson
fmt.Println(p1 == firstPerson(p4)) // cannot convert p4 (variable of type fourthPerson) to type firstPerson

// ❗Анонимные структуры можно сравнивать без преобразования, если типы структур одинаковые❗
var p1_2 = firstPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}
var anonim_p = struct {
	firstName string
	lastName string
}{
	firstName: "Dima",
	lastName: "Fominenkov",
}
fmt.Println(p1_2 == anonim_p) // true – можно без явного преобразования значения анонимной стуктуры

var anonim_p2 = struct {
	lastName string
	firstName string
}{
	lastName: "Fominenkov",
	firstName: "Dima",
}
fmt.Println(p1_2 == anonim_p) // invalid operation: p1 == anonim_p2 (mismatched types firstPerson and struct{lastName string; firstName string})
```
## 4. Блоки, затенение переменных и управляющие конструкции
1. Переменные можно объявлять вне функций, в качестве параметров функции или в качестве локальной переменной функции.
2. **Блок** – место, в котором делаем то или иное объявление.
3. **Блок пакета** – глобальное пространство в go.
4. **Блоки определяются** с помощью `{}`
5. Затенение переменный – объявление переменной в нижнем блоке с тем же идентификатором, что и у переменной в верхнем блоке
```go
a := 10
if x > 5 {
	fmt.Println(a) // 10
	// здесь новое объявление ЗАТЕНЯЕТ предыдущее, в блоке выше
	a := 5 // или `var a int` или `a, b := 5, 20`
	fmt.Println(a) // 5
}
fmt.Println(a) // 10

// ❗НЕЛЬЗЯ ЗАТЕНЯТЬ ИМЕНА ПАКЕТОВ❗
import "fmt"

func main() {
	a := 10
	fmt.Println(a)
	fmt := "oops"
	fmt.Println(a) // fmt.Println undefined (type string has no field or method Println)
}
```
6. При наличии затеняющей переменной НЕ можем получить доступ к затененной переменной.
7. В go есть так же ВСЕОБЩИЙ БЛОК(universe block) – блок, который содержит в себе идентификаторый функций, констант по типу `len()`, `copy()`, `true, false`
```go
// ❗НЕЛЬЗЯ ЗАТЕНЯТЬ ИМЕНА ИЗ ВСЕОБЩЕГО БЛОКА❗
fmt.Println(true) // true
true := 10
fmt.Println(true) // 10
```
8. ОПЕРАТОР `if`:
```go
n := rand.Intn(10)
if n == 0 {
	a := n * 10
	fmt.Println("n is zero", n)
	fmt.Println(a) // естественно, здесь доступны переменные и `n`, и `a`
} else if n > 5 {
	fmt.Printf("%d>5", n) // здесть доступна только `n`, `a` не доступна
} else {
	fmt.Println("else")
}
fmt.Printf("n is %d", n) // n здесь доступна
```
8. В go можно объявить переменные, которые будут видны не только в одном блоке(ветки) if или else, а сразу во всех блоках(ветвях) if-else:
```go
if n := rand.Intn(10); n == 0 {
	fmt.Println("n is zero", n)
} else if n > 5 { // ❗МОЖЕМ использовать `n` во ВСЕХ ВЕТВЯХ❗
	fmt.Printf("%d>5", n) // здесь `n` доступна
} else {
	fmt.Println("else", n) // здесь `n` доступна
}
fmt.Printf("n is %d", n) // ❗`n` здесь НЕДОСТУПНА❗
```
9. ОПЕРАТОР `for` – единственный способ организации циклов в go. Варианты for:
	1. Полный
	   ```go
// можно использовать только `:=`, `var` нельзя
for i := 0; i < 5; i++ {
	fmt.Println(i)
}

// ❗можно ПЕРЕЙТИ НА СЛЕДУЮЩУЮ ИТЕРАЦИЮ используя оператор `continnue`❗
for i := 0; i < 5; i++ {
	if i%2 == 0 && i%5 == 0 {
		fmt.Println("FizzBuzz")
		// если код перейдет в этот блок, то он уже не пойдет в другие
		// и выведет только строку "FizzBuzz"
		continue
	}

	if i%2 == 0 {
		fmt.Println("Fizz")
		continue
	}


	if i%5 == 0 {
		fmt.Println("Buzz")
		continue
	}
}
```
	2. Только с условием:
	   ```go
i := 0
for i < 5 {
	fmt.Println(i)
	i++	
}
```
	3. Бесконечный:
	   ```go
// бесконечно будет выводить строку "Hello"
for {
	fmt.Println("Hello")
}

// ❗чтобы ПРЕРВАТЬ БЕСКОНЕЧНЫЙ ЦИКЛ используем `break`❗
for {
	// ...
	if !CONDITION { // тут с `!`, т.к. тут мы проверяем УСЛОВИЕ ПРЕРЫВАНИЯ
		break // выходим из бесконечного цикла
	}
}
// аналог из Java
do {
	// ...
} while(CONDITION); // тут без `!`, т.к. тут мы проверяе УСЛОВИЕ ВЫПОЛНЕНИЯ
```
10. ОПЕРАТОР `for-range` – выполняет обход элементов только для встроенных(и пользовательских на их основе) типов данных:
    *в большинстве случаев стоит выбирать `for-range` для реализации логики*
	1. Массив/срез
	   ```go
ages := []int{2, 4, 6, 8, 10, 12}
// `i` – индекс, `v` – значение
for i, v := range ages {
	fmt.Println(i, v)
}
// 0 2
// 1 4
// 2 6
// ...
// 5 12

// ❗`_` пустой идентификатор, когда нам не нужно использовать индекс❗
for _, v := range ages {
	fmt.Println(v)
}
```
	2. Карта:
	   *итерация по картам происходит в рандомном порядке исходя из требований безопасности и надежности работы программ(но `fmt.Println(usersAges) выводит всегда в одном порядке для удобства`)*
	```go
usersAges := map[string]int{"Dima": 24, "Katya": 21, "Sasha": 25, "Tema": 24,}
for k, v := range usersAges {
	fmt.Println(k, v)
}

// ❗При итерации по карте итерируется в рандомном порядке❗

// Запускаем 1-й раз
// Katya 21
// Dima 24
// Sasha 25
// Tema 24

// Запускаем 2-й раз
// Sasha 25
// Katya 21
// Tema 24
// Dima 24

// Запускаем 3-й раз
// Dima 24
// Sasha 25
// Tema 24
// Katya 21


// Симулируем множество(set) при помощи карты
uniqueNames := map[string]bool{
	"Dima": true,
	"Katya": true,
	"Sasha": true,
	"Tema": true,
}
// можем опустить вторую переменную,
// в данном случае значение, которое всегда true,
// если она нам не нужна
for k := range uniqueNames {
	fmt.Println(k)
}
// Dima
// Sasha
// Katya
// Tema
```
	3. Строки:
	   *обход производится по рунам, а не байтам*
	```go
samples := []string{"hello", "apple_Ж!", "Мир𐜲!"}
for i, sample := range samples {
	fmt.Printf("Sample %d:\n", i+1)
	for i, r := range sample {
		fmt.Println(i, r, string(r))
	}
}

Sample 1:
0 104 h // ❗104 – РУНА – unicode номер символа❗
1 101 e
2 108 l
3 108 l
4 111 o
Sample 2:
0 97 a
1 112 p
2 112 p
3 108 l
4 101 e
5 95 _
6 1046 Ж // ❗Индекс 7 пропушен, т.к. символ Ж занимает 2 байта❗
8 33 !
Sample 3:
0 1052 М
2 1080 и
4 1088 р
6 67378 𐜲 // ❗Индексы 7, 8, 9 пропушен, т.к. символ 𐜲 занимает 4 байта❗
10 33 !

// Диапазоны unicode символов и их вес
// 0-127 – 1 байт
// 128-2047 – 2 байта
// 2048-65535 – 3 байта
// 65536-1114111 – 4 байта
```
	4. Каналы – `for-range` предоставляет удобную работу с каналами, о ней позже
11.  Цикл `for-range` **копирует значения**:
    *НО ТОЛЬКО У ТЕХ СТРУКТУР, КОТОРЫЕ МОЖНО СКОПИРОВАТЬ*
```go
evenVals := []int{2, 4, 6, 8, 10, 12}
for _, v := range evenVals {
	v *= 2
}
fmt.Println(evenVals) // [2 4 6 8 10 12]

// Если взять map, то будем изменять оригинальные значения, т.к. ❗map – ссылка на структуру❗
users := []map[string]string{
	{"Name": "Dima"},
	{"Name": "Katya"},
	{"Name": "Sasha"},
}

for _, user := range users {
	user["Name"] += "1"
	fmt.Println(user)
}
fmt.Println(users) // [map[Name:Dima1] map[Name:Katya1] map[Name:Sasha1]]
```
12. Метки – возможность дать циклу идентификатор и применять `break`, `continue` именно для него даже из вложенных циклов `for`:
```go
func main() {
	samples := []string{"hello", "apple_Ж!", "Мир𐜲!"}
outer: // Наша метка. Она автоматически форматируется на уровне внешнего блока
	for _, sample := range samples {
		for _, r := range sample {
			fmt.Println(r, string(r))
			if r == 'l' {
				continue outer // Здесь переходим к следуюещй итерации
				               // именно внешнего цикла for с меткой
			}
		}
	}
}
```
13. ОПЕРАТОР `switch` – позволяет писать цепочки проверок:
```go
samples := []string{"hello", "apple_Ж!", "Мир𐜲!"}
for _, v := range samples {
	switch wordLen := len(v); wordLen {
		case 1, 2, 3, 4, 5:
			// не нужно писать break, т.к. нет автоматического проваливания
			// если НАДО провалиться – используем `fallthrough`, антипаттерн
			fmt.Println("short")
		case 6, 7:
			fmt.Println("right length", n)
		case 8, 9: // в это ветки НИЧЕГО не произойдет, она ничего не выведет
		default:
			fmt.Println("long")
	}
}

for _, v := range samples {
	switch wordLen := len(v); { // НЕ УКАЗЫВАЕМ значение для `switch`
		case wordLen < 5: // тогда можем писать условия в ветках
			fmt.Println("short")
		case wordLen > 7:
			fmt.Println("long", n)
		default:
			fmt.Println("right len")
	}
}
```
14. ОПЕРАТОР `goto` – позволяет перейти из одного места программы в другое, отмеченное меткой
    *ЛУЧШЕ НЕ ИСПОЛЬЗОВАТЬ*
    Правила:
	1. Нельзя пропускать объявления переменных
	2. Нельзя переходить во вложенный или параллельный блок
	```go
func main() {
	a := 10
	goto skip // ./prog.go:7:7: goto skip jumps over declaration of b at ./prog.go:8:4
	b := 20
skip
	c := 30
	fmt.Println(a, b, c)
	if c > a {
		goto inner // ./prog.go:13:8: goto inner jumps into block starting at ./prog.go:16:11
	}
	
	if a < b {
	inner:
		fmt.Println("a is less than b")
	}
}
```
## 5. Функции
1. Объявление функций:
```go
// func – ключевое слово
// div – название функции
// (...) – скобки, в которых могут быть, а могут и не быть параметры функции
// numerator int, denominator int – параметры через запятую, у каждого его тип
// ) int { – тип возвразаемого значения, может быть не указан, если функция ничего не возвращает, если указан обязательно должен быть return в функции
func div(numerator int, denominator int) int {
	if denominator == 0 {
		return 0
	}

	return numerator / denominator
}

var names = []string{"Dima", "Katya", "Alexandr"}
// функция ничего не принимает и не возвращает
func main() {
	for _, name := range names {
		if len(name) > 5 {
			fmt.Println("Name is too long. Quit from the program")
			return // даже если функция ничего не вохвращает можем указать return для преждевременного выхода из функции
		}
	}

	fmt.Println("All names are right")
}

// если есть несколько параметров одинакового типа друг за другом – можем указать тип только у последнего
// num1, num2, num3 – все они имеют тип int
func calc(num1, num2, num3 int, operator string) int {
	...
}
```