---
tags:
  - книги
  - программирование
  - backend
  - programming_base
  - go
автор: Джон Боднер
год: 2025
начал читать: 2024-12-31
закончил читать: 
количество страниц: 411
оценка(0/10): 
прочитал n-раз: 
цена: 1500
---

### Резюме
==Добавьте краткие итоги и свои впечатления о книге. Что нового вы узнали и какие ее особенности?==

## 1. Настройка среды разработки
1. В go из коробки идет форматтер, который имеет строгие дефолтные стили, которые нельзя поменять. Это нужно для оптимизации компилятора, разрешения споров по поводу стиля, удобства разработки.
2. `go run hello.go` – компилирует программу, запускает ее, но не сохраняет бинарник
3. `go build hello.go` – компилирует программу и сохраняет бинарник в текущей директирии
4. Для билда go-кода нужно устанавливать язык на устройство, для запуска скомпилированной программы нужен только сам бинарный файл программы и ничего кроме
5. make-файлы позволяют выполнять определенные шаги, а не запускать отдельную команду `make`(`make lint` – для запуска конкретной цели):
```yml
# команда build будет выполняться по-умолчаю, если не указан шаг(цель)
.DEFAULT_GOAL=build

# "fmt" – название шага
fmt:
	go fmt ./...
.PHONY:fmt

# "lint" – название шага,
# "fmt" – шаг, который должен выполниться перед запуском "lint"
lint: fmt
	golint ./...
.PHONY:lint

vet: fmt
	go vet ./...
.PHONY:vet

build: vet
	go build hello.go
.PHONY:build
```

## 2. Простые типы и объявление переменных

1. Нулевое значение –  присваивается по-дефолту любой переменной, которая была объявлена, но не была инициализирована
2. Литералы:
	1. Целочисленные – числа с основанием 10, 2`0b`, 8`0o`, 16`0x`, можно разделять числа `1_2_3`, но лучше использовать для разделения разрядов тысяч `1_024`
	2. С плавающей запятой – содержит запятую, отделяющую дробную часть значения, можно возводить в степень `3,14e3`, можно записывать в 16-м виде с префиксом `0x` и разделителем степени `p`
	3. Руны – символы, **заключаются в одинарные(`''`) кавычки**
	   *в go одинарные и двойные кавычки не являются взаимозаменяемыми*
	4. Строки – последовательность символов
		1. **интерпретируемый** строковый литерал(`""`) – `"Hello, World!"`, можно экранировать, вставлять новые строки `"Hello,\n\"World!\""`
		2. **необработанный** строковый литерал(\`) – \`Hello,<перенос строки>Wordl!\`
3. Литералы в go являются нетипизированными, по типу `1` – литерал целого числа, а его тип `int64`, `int32` и т.д. определяется уже в месте использования
4. Логические(`bool`) – `true`, `false`
   *нулевое значение  – `false`*
```go
var flag bool // по-умолчанию false
var isAwesome = true
```
5. Числовые типы – `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`
   *нулевое значение для числовых типов – `0`*
	1. `byte` – псевдоним типа `uint8`\[0, 255\], **стоит использовать именно `byte`**
	2. `int`/`uint` – в 64-х разрядной ОС это `int64`, в 32-х разрядной ОС это `int32`, поэтому **НЕЛЬЗЯ напрямую взаимодействовать между `int`, `int32`, `int64`** – нужно явно приводить типы
	   *`int` является целочисленным типо по-умолчанию*
	3. `rune` – псевдоним типа `int32`, используется для представления кодовой точки Unicode
	4. `uintptr` – ***ДОПИСАТЬ***
6. Какой целочисленный тип использовать?
	1. Если работаем с файлами двоичного формата или сетевыми протоколами – используем их разрядность
	2. Если пишем библиотечные функции, может потребоваться написать миниму две функции для `int64` и `uint64`, максимум – для всех типов
	3. В других случаях просто используем `int`, иначе будет считаться преждевременной оптимизацией
7. Типы с плавающей запятой – `float64`, `float32`
   *по-умолчанию `float32`*
	1. По поводу использования памяти можно не заморачиваться, пока не скажет профайлер
	2. Числа с плавающей запятой являются НЕТОЧНЫМИ, т.к. имеют ограниченное число знаков после запятой и не могут отразить все значения, могут только приблизительные
	3. ЕСЛИ ВАЖНА ТОЧНОСТЬ – НЕ ИСПОЛЬЗУЕМ ЧИСЛА С ПЛАВАЮЩЕЙ ЗАПЯТОЙ
	4. Из-за примерного представления числа два, казалось бы, одинакового числа могут быть не равны
8.  В go НЕТ автоматического повышения типов числа(например, с  `int32` до `int64`), мы должны ЯВНО их преобразовывать
```go
var a int = 10
var b float64 = 3.14
var c = float64(a) * b
var d = a + int(b)
```
9. ВСЕ преобразования типов в go выполняются ЯВНЫМ образом
   ***ни один тип не может быть явно или неявно преобразован в логический**, для этого нужно использовать операторы сравнения*
```go
var a = 0
var b = ""
// неправильно, надо явно if a != 0
if a {
	...
}

// неправильно, надо явно if b != ""
if b {
	...
}
```
 ***Определение переменной***
10. `var` с типом:
```go
var x int = 1
```
11. `var`  без типа, если устраивает тип по-умолчанию:
```go
var x = 1 // int
```
12. `var` с типо без значения, если хотим явно задать переменной нулевое значение определенного типа:
```go
var x int // 0
var y string // ""
var z bool // false
```
13. `var` с объявлением нескольких переменных:
```go
var a, b int = 1, "str"
var c, d int // 0, 0
var x, y = 1, "str"
```
14. `var` с списком объявлений:
```go
var (
x int
y = 20
z int = 30
d, e = 1, "hello"
f, g string // "", ""
)
```
15. `var` НЕ может переопределить уже существующую переменную
```go
var a = 10
var a = 20 // a redeclared in this block, other declaration of a
```
17. `:=` – **только внутри функций**)
```go
x := 10
y, z := 10, "hello"
```
18. `:=` – МОЖЕТ ПЕРЕОПРЕДЕЛИТЬ уже существующую переменную, ЕСЛИ переопределяем **+** создаем новую переменную:
```go
x := 10
x, y := 20, 30
y := 40 // no new variables on left side of :=
```
19. `:=` – **нельзя использовать вне функции**
20. `const` – позволяют определить неизменяемые значения
    *по сути, просто способ присвоения имен литералам*
```go
const x int64 = 10
const (
	idKey = "id"
	nameKey = "name"
)
const z = 10 * 20
```
21. `const` позволяет использовать только значения, вычисляемые на этапе компиляци, поэтому нельзя определять ничего кроме: числовых, строковых, булевых литералов, рун, а так же встроенных функций complex, real, imag, len, cap + вычисляемые с операторами(+, - и т.д.)
    *в go НЕЛЬЗЯ сделать массив, срез, свойство структуры неизменяемым*
22. для всех переменных/констант используется `camelCase`
## 3. Составные типы
1. Массив – структура данных **фиксированной длины**:
```go
var a [3]int // массив из 3-х элементов, каждый элемента типа int; т.к. не указали значения, будет массив из нужевых значений типа int {0, 0, 0}
var b = [3]int{10, 20, 30}
var c = [12]int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
var d = [...]int{10, 20, 30} // если сразу добавляем значения – можем не указывать размерность, а использовать(ОБЯЗАТЕЛЬНО) `...`
```
2. Для сравнения массивов используем `==`, `!=`:
```go
var a = [3]int{10, 20, 30}
var b = [...]int{10, 20, 30}
fmt.Print(a == b) // true
```
3. Чтение/запись происходит через `a[0] = 10`, `fmt.Print(a[2])`
	1. Если длина массива ***заранее известна***(задана с помощью константы/литерала), то при выходе за границы массива получим ошибку компиляции
	2. Если длина массива ***определяется на этапе выполнения***, то код скомпилируется, но при выходе за границы выдаст панику
4. ***ДЛИНА МАССИВА ЯВЛЯЕТСЯ ЧАСТЬЮ ЕГО ТИПА***, т.е. `[3]int` и `[4]int` имеют разный тип. Из этого следует:
	1. Не можем использовать **переменную** для создания типа, т.к. для создания типа на этапе компиляции должна быть известна размерность массива
	2. ***Нельзя преобразовать массив одного типа, в массив другого типа***
	   Итог: нельзя написать функцию, обрабатывающую разные массивы
5. ***МАССИВЫ СТОИТ ИСПОЛЬЗОВАТЬ ТОЛЬКО ТОГДА, КОГДА ЗАРАНЕЕ ИЗВЕСТНА ЕГО ДЛИНА***
6. ***СРЕЗ – переменная длина; длина не является составной частью типа***
```go
var a = []int{10, 20, 30} // как массив, но НЕ указываем длину
var c = []int{1, 5: 4, 6, 10: 100, 15} // можем указать только значения для определенных индексов – остальные будут нулевыми значениями типа: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
```
7. ***Нулевое значение среза – `nil`:***
   *`nil` не `null`; о `nil` позже, в главе 6*
```go
var a []int // НЕ пустой срез, а nil
```
8. Срез является не сравниваемым, можно только проверить на равенство/неравенство `nil`:
```go
var a []int
fmt.Print(a == nil) // true
var b = []int{1, 3}
fmt.Print(a == b) // invalid operation: a == b (slice can only be compared to nil)
```
10. `len: func len(v Type) int` – встроенная функция, возвращает длину массива/среза 
    *в go нельзя самому написать функции, подобные `len`*
```go
var a = []int{10, 20, 30}
fmt.Print(len(a)) // 3

var b []int // nil
fnt.Print(len(b)) // 0
```
11. `append: func append(slice []Type, elems ...Type) []Type` – встроенная функция, позволяет добавлять новые элементы в массив:
    *в go аргументы в функции передаются по-значению, т.е. каждый раз при вызове ф-ии передается не само значение, а его копия, `append` добавляет новый элемент в копию и возвращает новый срез, который нужно присвоить – иначе будет ошибка*
```go
var x []int
// ❗обязательно надо присвоить результат выполнения функции append тому же массиву❗
x = append(x, 10)
x = append(x, 20, 30, 40)
append(x, 50) // append(x, 50) (value of type []int) is not used
```
12. Емкость среза – количество зарезервированной памяти для массива. Например, у нас есть срез с длинной 5. Но его емкость может быть больше для возможности добавления новых элементов без копирования и перемещения данных.
    *Массив – структура данных, в которой все элементы находятся рядом друг за другом. Go автоматически увеличивает емкость массива по мере добавления туда новых элементов и переноса массива.*
```go
// ячейки памяти
// [10][20][30][40][50][][] [другие][данные] – длина 5, но у нас на 2 ячейки памяти больше, чтобы могли добавить еще 2 элемента
var a = []int{10, 20, 30, 40, 50}
a = append(a, 60, 70)
// [10][20][30][40][50][60][70] [другие][данные]
a = append(a, 80) // при добавлении нового элемента go должен будет перенести массив в новое место
// [10][20][30][40][50][60][70] 80 [другие][данные] – не можем добавить, т.к. больше нет сместа по-соседству => надо переместить массив в другое место


var c = cap(a) // 8, для определения емкости массива
```
13. `make: func make(t Type, size ...IntegerType) Type` – встроенная функция, позволяющая определить срез типа с размером(длиной) и емкостью(опционально):
    *значение емкости не может быть меньше значения длины*
```go
var a = make([]int, 3) // [0][0][0]
var b = make([]string, 4, 7) // [""][""][""][""][][][]
// append всегда увеличивает длину среза
b = append(b, "5", "6") // [""][""][""][""]["5"]["6"][]

// функция make([]int, 3) создает не nil, а массив определенной длины с нулевыми значениями типа среза []int{0, 0, 0}, т.е.
var c = make([]int) // []int{}
var d []int // nil
fmt.Print(c == d) // false
```
14. Можно срезать срезы `a[индекс начала:индекс конца]`:
```go
var a = []int{10, 20, 30, 40, 50, 60}
var b = a[1:3] // [20, 30]
var c = a[:4] // [10, 20, 30, 40]
var d = a[2:] // [40, 50, 60]
var e = a[:10] // panic: runtime error: slice bounds out of range [:10] with capacity 6
```
15. Срезы используют ту же область памяти, что и изначальный массив, т.е. если изменить изначальный срез или один из его срезов, то изменятся все связанные срезы:
    *длина у подсреза, а емкость = `емкость основного массива - сдвиг начала`*
```go
var a = []int{10, 20, 30, 40} // 0[10]1[20]2[30]3[40], len 4, cap 4
var b = a[:2] // 0[10]1[20], len 2, cap 4
var c = a[1:] // 1[20]2[30]3[40], len 3, cap 3
a[1] = 2
b[0] = 1
c[1] = 3
// a, b, c: [1][2][3][40], [1][2], [2][3][40]
```
16. КРАЙНЕ НЕЖЕЛАТЕЛЬНО использовать `append` вместе со срезами срезов, лучше вообще не изменять срезы после их срезания
17. Можно срезать массивы – получится срез:
```go
var a = [4]int{1, 2, 3, 4}
var b = a[:2] // []int{1, 2}
var c = a[:] // []int{1, 2, 3, 4} – по сути делам срез из массива
```
18. `copy: func copy(dst, src []Type) int` – встроенная функция, которая позволяет скопировать срез **С ОТДЕЛЬНОЙ** областью памяти, отличной от области памяти базового среза:
    *возвращает количество скопированных элементов, которое можно игнорировать*
```go
var a = []int{1, 2, 3, 4, 5}
var b = make([]int, 4)
var c = copy(b, a) // 4 – было скопировано 4 элемента, т.к. длина слайса b – 4
fmt.Print(b) // [1, 2, 3, 4] нет последнего элемента(5), т.к. длина слайса b – 4
b[0] = 10

fmt.Print(b) // [10, 2, 3, 4, 5] – первый элемент изменился
fmt.Print(a) // [1, 2, 3, 4] – первый элемент НЕ изменился, т.к. теперь a и b – разные области памяти

------- Противопоставление со срезом
var a = []int{1, 2, 3, 4}
var b = make([]int, 4)
b = a[:]
fmt.Print(b) // [1, 2, 3, 4]
b[0] = 10

fmt.Print(b) // [10, 2, 3, 4] – первый элемент изменился
fmt.Print(a) // [10, 2, 3, 4] – первый элемент ТОЖЕ ИЗМЕНИЛСЯ, т.к. a и b используют одну область памяти
-------

var e = []int{1, 2, 3, 4, 5}
var f = make([]int, 2)
copy(f, e[2:])
fmt.Print(f) // [3, 4]

var g = [7]int{10, 20, 30, 40, 50, 60, 70}
copy(g[2:4], e[3:]) // можем копировать в определенные индексы таргет среза(массива)
fmt.Print(g) // [10, 20, 4, 5, 50, 60, 70]
```
19. Строка в go состоит из неизменяемой последовательности `byte`
20. Со строками можно использовать доступ по индексу, срезы, получение длины:
```go
var a = "Hello there"
var b byte = a[6] // t
var c string = a[:5] // "Hello"
var d string = a[5:6] // " "
var e string = a[7:] // "there"
var f = len(a) // 11
```
21. Строки состоят из символов UTF-8, длина одного символа может быть от 1 до 4 байт, следовательно, если длина символа более 1-го байта, то взятие слайса, получение символа по индексу, получение длины может быть ошибочным:
```go
var a = "Hello ☼"
var b byte = a[0] // H – все окей, т.к. длина символа H – 1 байт
var c string = a[:5] // "Hello" – тут тоже все окей, т.к. размер символов английского алфавита – 1 байт
var d byte = a[7] // ?? – непонятный символ, т.к. мы взяли только первый(из 3-х) байт символа ☼
var e string = a[7:] // "☼" – взяли все байты символа ☼
var f = len(e) // 3 – длина символа ☼
var g = len(a) // 9, а не 7, т.к. длина символа ☼ равна 3
```
22. Для извлечения из строк подстрок или кодовых точек нужно использова встроенную библиотеку `strings` или `unicode/utf8`
23. Карты `map` – соединяет ключи и значения `map[тип_ключа]тип_значения`:
    *нулевое значение `nil`; карты в go реализованы при помощи [хэш-таблиц](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)*
```go
var a map[string]int // nil
var b map[string]string // nil
fmt.Println(len(a)) // 0

// ❗можно читать значения у нулевого map – всегда будет возвращать нулевой тип значения❗
fmt.Println(a["a_key_1"]) // 0 – нулевое значение типа int
fmt.Println(b["b_key_1"]) // "" – нулевое значение типа string

// ❗нельзя записывать значения в nil-карту❗
a["a_key_1"] = 1 // panic: assignment to entry in nil map

var c = map[string]int{} // map[string]int{} – пустой 
fmt.Println(len(c)) // 0

// ❗можно читать значения у пустого литерала карты – всегда будет возвращать нулевой тип значения❗
fmt.Println(с["с_key_1"]) // 0

// ❗можно записывать значения в пустой литерал карты❗
с["с_key_1"] = 1
fmt.Println(с["с_key_1"]) // 1

var d = make(map[string]int, 2) // пустой литерал карты длиной 2
d["d_key_1"] = 1
d["d_key_2"] = 2
// можно добавлять значения сверх длины карты – она увеличится автоматически
d["d_key_3"] = 3
d["d_key_3"]++
fmt.Println(d["d_key_3"]) // 4

var e = map[string][]string{
	"key1": []string{"a", "b", "c"},
	"key2": []string{"d", "e", "f"},
	"key3": []string{"j", "h", "k"},
}
e["key1"] // nil
```
24. Идиома "запятая-ok" – позволяет определить, была пара ключ-значение задана или же нам вернулось нулевое значение типа значения:
```go
var a = map[string]int{
	"key_1": 1,
	"key_2": 2,
}
v, ok := a["key_1"] // "key_1" содержится в карте "a", поэтому v == 1, "ok" == true, 
v, ok := a["key_3"] // "key_3" НЕ содержится в карте "a", поэтому v == 0, "ok" == false
```
25. `delete: func delete(m map[Type]Type1, key Type)` – встроенная функция, позволяющая удалить пару ключ-значение из карты по ключу:
```go
var a = map[string]int{
	"key_1": 1
}
delete(a, "key_1")
```
26. Карта в качестве множества `set` – позволяет хранить только уникальные значения:
    *в go нет реализации `set` из коробки*
```go
// bool занимает 1 байт памяти
var intSet = map[int]bool{}
var vals = []int{1, 1, 1, 2, 3, 4, 4, 5, 6, 6, 6}
for _, v := range vals {
	intSet[v] = true
}
fmt.Println(intSet) // {1:true,2:true,3:true,4:true,5:true,6:true,} – только уникальные значения

// можно использовать пустую структуру struct{} – занимает 0 байт => более эффективно, НО для проверки надо будет использовать идиому запятая-ok
var intSet2 = map[int]struct{}{}
var vals = []int{1, 1, 1, 2, 3, 4, 4, 5, 6, 6, 6}
for _, v := range vals {
	intSet2[v] = struct{}
}
fmt.Println(intSet2) // {1:struct{},2:struct{},3:struct{},4:struct{},5:struct{},6:struct{},} – только уникальные значения
```
27. ***Структуры*** – позволяет определить определенный вид данных с конкретными ключами и их значениями:
	*НУЛЕВОЕ ЗНАЧЕНИЕ – СТРУКТУРА, ВСЕ ПОЛЯ КОТОРОЙ ИМЕЮ НУЛЕВЫЕ ЗНАЧЕНИЯ ТИПА ПОЛЯ*
    *карты не позволяют задать определенные ключи, а так же позволяют использовать только один тип в качестве значения*
```go
// Можно определять структуры на уровне модуля
type person struct {
	name string
	age int
	pet string
}

var p person // person{ name: "", age: 0, pet: "" }

// Можно внутри функции
func foo() {
	type fooPerson struct {
		firstName string
		lastName string
	}

	// Тип, объявленный в функции можно использовать только в ней(или ниже)
	fp := fooPerson{} // fooPerson { firstName: "", lastName: "" }
}

// Можно создавать экземпляры структуру без указания названия полей, НО все ЗНАЧЕНИЯ полей должны быть В ТОМ ЖЕ ПОРЯДКЕ КАК БЫЛИ ОБЪЯВЛЕНЫ В ТИПЕ СТРУКТУРЫ
var p1 = person {
	"Dima",
	24,
	"cat",
} // person{name:"Dima",age:24,pet:"cat",}

// Можно создавать экземпляр с указанием имени полей, тогда можно указывать в произвольном порядке – предпочтительный вариант создания
var p2 = person {
	age 21,
	pet "rat",
	name "Kate",
} // person{name:"Kate",age:21,pet:"rat"}

// Для доступа используется точечная нотация
p.name = "Dima"
p.age = 24
p.pet = "cat"
fmt.Println(p.name) // "Dima"
```
28. ***Анонимные структуры*** – позволяют определить тип структуры прямо во время инициализации переменной:
```go
var p = struct {
	name string
	age int
	pet string
}{
	name: "Dima",
	age: 24,
	pet: "cat",
}

var a = []struct {
	value string
}{
	{ value: "1" },
	{ value: "2" },
}
```
29. Сравнение структур:
	1. Если все значения структуры сравниваемые – то и сама структура сравнимаемая
	2. Если есть хотя бы одно несравниваемое, например, слайс – то и сама структура несравниваемая
30. В go НЕЛЬЗЯ СРАВНИВАТЬ ЗНАЧЕНИЯ РАЗНЫХ ТИПОВ, поэтому даже если есть две одинаковые структуры, то напрямую значения сравнить нельзя. Для сравнения нужно **преобразовать** один тип в другой, **если у типов идентичные названия полей, их значения, а так же порядок**:
```go
type firstPerson struct {
	firstName string
	lastName string
}

type secondPerson struct {
	firstName string
	lastName string
}

type thirdPerson struct {
	firstName string
	lastName string
	age int
}

type fourthPerson struct {
	lastName string
	firstName string
}

var p1 = firstPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}

var p2 = secondPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}

var p3 = thirdPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
	age: 24,
}

var p4 = fourthPerson {
	lastName: "Fominenkov",
	firstName: "Dima",
}

fmt.Println(p1 == p2) // invalid operation: p1 == p2 (mismatched types firstPerson and secondPerson)
fmt.Println(p1 == firstPerson(p2)) // true
fmt.Println(p1 == firstPerson(p3)) // cannot convert p3 (variable of type thirdPerson) to type firstPerson
fmt.Println(p1 == firstPerson(p4)) // cannot convert p4 (variable of type fourthPerson) to type firstPerson

// ❗Анонимные структуры можно сравнивать без преобразования, если типы структур одинаковые❗
var p1_2 = firstPerson {
	firstName: "Dima",
	lastName: "Fominenkov",
}
var anonim_p = struct {
	firstName string
	lastName string
}{
	firstName: "Dima",
	lastName: "Fominenkov",
}
fmt.Println(p1_2 == anonim_p) // true – можно без явного преобразования значения анонимной стуктуры

var anonim_p2 = struct {
	lastName string
	firstName string
}{
	lastName: "Fominenkov",
	firstName: "Dima",
}
fmt.Println(p1_2 == anonim_p) // invalid operation: p1 == anonim_p2 (mismatched types firstPerson and struct{lastName string; firstName string})
```