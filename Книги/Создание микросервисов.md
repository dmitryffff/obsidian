[Схемы](https://app.diagrams.net/#G1UJt4xv9QZYIfyRWlJfuAsCnT4tj-gDg7#%7B%22pageId%22%3A%22IMx9VPlgQBP8EnmAfyif%22%7D)
> ***Микросервисы*** – подход к распределенным системам, при котором используются небольшие сервисы, каждый из которых можно независимо друг от друга разрабатывать, тестировать, выпускать.
> 
> ***Монолит*** – когда все функциональные возможности приложения должны развертываться вместе.

>[!info]
>**Связанность(coupling)** – зависимость кода друг от друга. Т.е. при изменении функциональность в одном месте необходимо менять функциональность в другом. *<span class="failure-text">Высокая связанность</span>* - высокая зависимость, *<span class="success-text">низкая связанность</span>* - низкая зависимость. ^coupling

>[!info]
>**Связность(cohesion)** – логическая связанность между частями модуля(программы). Т.е. все части внутри модуля имеют определенную четкую роль и способствуют достижению цели этого модуля. ^cohesion
# Часть 1 – Основы
## Глава 1 – Что такое микросервисы?
1. Микросервисы моделируются вокруг предметной области бизнеса, инкапсулирует функциональность и делает ее доступной при помощи сетей.
2. Чаще всего не используются общие базы данных, т.е. **для каждого сервиса отдельная бд.**
3. В микросервисах отдаем приоритет сильной [[#^cohesion|связности]] бизнес-функциональности, а не технической функциональности.
4. **Необходимо избегать использования общих баз данных.**
5. Про размеры:
	1. Микросервис должен быть такого размера, чтобы его можно было легко понять;
	2. “*Микросервис должен быть размером с вашу голову”* – Джеймс Льюис;
	3. **В начале работы лучше не беспокоиться о размере микросервиса.**
7. Разделение команды:
	1. Компании создают проекты, коммуникация в которых происходит так же, как и коммуникация в компании, т.е. если внутри компании есть девопс-инженеры, бэкенд-разработчики и фронтенд-разработчики, то и сам проект будет состоять из таких же 3-х частей. В итоге, проект будет выглядеть так, а внесение изменений(в большинстве случаев) потребует затрагивания всех трех слоев:
	   ![[Трехуровневая команда.png]]
	2. Если мы хотим упростить способ внесения изменений – нужно пересмотреть способ группировки кода, выбрав связность бизнес-функциональности, а не технологий:
	   ![[Функциональная команда.png]]
7. Виды монолитных архитектур:
	1. Однопроцессорный монолит - система, весь код которой развертывается как единый процесс. Самый простой, одна программа, одна бд(может и не одна, но единые для программы в целом). С ростом команды растет и монолит.
	2. Модульный монолит – подмножество однопроцессорного, в котором код разделен на несколько модулей, а бд одна. Для развертывания модули все равно необходимо соединить. Неплохой вариант для параллельной работы команд, если правильно определить границы модулей.
	3. Распределенный монолит – состоящая из нескольких сервисов система, которую необходимо деплоить единовременно. Плохой вариант. Обладает недостатками и монолитной, и микросервисной архитектур.
8. **Монолит стоит рассматривать как решение по умолчанию. Т.е. “*назовите мне убедительную причину использовать микросервисы*“.**
9. Аггрегация логов очень важна(а в микросервисах еще и нетривиальна). Инструмент для аггрегации стоит рассматривать как обязательный.
10. ***“…сделайте все возможное, чтобы кто-то другой управлял кластером Kubernetes вместо вас"**, пусть даже и с использованием управляющего сервиса от облачного провайдера. Запуск собственного кластера может потребовать значительного объема работ!“*
11. Бессерверный подход – когда не думаем о количество используемых компьютеров, а просто запускаем код. Сервис сам масштабирует ресурсы по мере необходимости. Пример – *функция как услуга(FaaS, function as a service)(Firebase).*
12. <span class="success-text">Преимущества микросервисов:</span>
	1. Технологическая неоднородность – т.к. мы скрываем информацию внутри микросервиса, предоставляя только внешнее api, а так же из-за того, что наш микросервис – отдельный, не связанный с другими модуль, мы можем использовать различный технологии(языки, фреймворки).
	2. Надежность – выход из строя одного сервиса не повлияет на работоспособность всей программы, только может только на какие-то связанные. Но для этого нужно организовать перебор(bulkhead) микросервисов(периодически пингуем микросервисы), чтобы вовремя обнаружить вышедшие из строя. НО у нас появляется новый источник ошибок – СЕТИ. **СЕТИ МОГУТ И БУДУТ ЛОМАТЬСЯ**.
	3. Масштабирование – при монолитной архитектуре если нам не хватает мощности придется масштабировать весь монолит. В микросервисной архитектуре можно масштабировать только отдельные микросервисы.
	4. Простое развертывание – при небольших изменениях в большом монолите нам придется деплоить веееесь монолит, при небольших изменениях в небольшом микросервисе придется деплоить только этот микросервис.
	5. Согласованность рабочих процессов – сотрудники в больших компаниях могут делиться на небольшие команды со своими зонами ответственности, что улучшает продуктивность.
	6. Можем использовать одни и те же микросервисы по-разному, в зависимости от того, кто и откуда обращается.
13. <span class="failure-text">Недостатки микросервисов:</span>
	1. Опыт разработчика.
	2. Технологическая перегрузка – микросервисы сами по себе тащат за собой большое количество дополнительных инструментов для эффективной работы с ними, а тут еще и у нас распускаются руки в выборе технологий для реализации микросервисов, что может повлечь большую неоднородность технологий. Нужно не переусердствовать с этим.
	3. Стоимость – микросервисы имеют свою цену, т.к. на построение такой архитектуры требуется больше времени и других ресурсов.
	4. Отчетность – у нас распределенная системы, у каждого микросервиса своя бд => **сложности аггрегацией данных для их анализа.** Решать пытаются при помощи *потоковой передачи данных, можно так же сливать все данные из разных бд в единую(или озера данных).*
	5. Мониторинг и устранение неполадок.
	6. Безопасность – у нас появляется взаимодействие между микросервисами по сети, которая имеет свои уязвимости.
	7. Тестирование.
	8. Время ожидания – теперь мы взаимодействуем не в рамках одного процесса, как в монолитной архитектуре, а между различными сервисами, в процессе общения которых происходят постоянные серилизация/десериализация данных и другие накладные процессы, которые могут снизить общий отклик системы.
	9. Согласованность данных – теперь вместо одной бд у нас их несколько и нам следует внимательно следить за тем, чтобы данные были полные и валидные.
14. Кому подойдут микросервисы – для больших команд с устоявшимися предметными областями.
15. Кому НЕ подойду микросервисы – небольшим командам, стартапам, командам с неустоявшейся предметной областью, т.к. повлекут только дополнительные расходы на реализацию и поддержку микросервисной архитектуры.
## Глава 2 Как моделировать микросервисы
1. Нужно стремиться к низкой [[#^coupling|связанности]]:
   ![[Виды связанности.png]]
2. Предметная связанность – когда одному микросервису нужна функциональность другого. Почти неизбежный вид связанности. Считается низкой связанностью, но все равно может нести <span class="failure-text">опасность</span>, если один микросервис использует большое количество других микросервисов, т.е. централизует большое количество логики. Пример: *Обработчик заказа* вызывает микросервис *Склад* для резервирования товара, а микросервис  *Оплата* принимает оплату.
   ![[Предметная связанность.png|450]]
   3. <span class="failure-text">Сквозная связанность</span> – когда наш микросервис вызывает другой микросервис только чтобы передать данные третьему микросервису. **Один из самых проблемных видов связанности**, т.к. наш микросервис должен мало того, что вызывать другой микросервис, так еще и знать, что тот второй микросервис вызовет третий. Так же первый, в таком случае, должен знать поведение обоих нижестоящих микросервисов. Пример: *Обработчик заказа* во время отправки запроса на заказ на *Склад* отправляет в полезной нагрузке путевой лист, который содержит адрес и тип доставки, которые необходимы сервису *Доставка*. Если сервису *Доставка* потребуется что-то изменить, то, скорее всего, и вышележашим сервисам *Обработчик заказов* и *Склад* придется что-то менять. ![[Сквозная связанность 1.png|500]]
   4. Есть различные <span class="success-text">варианты решения</span> <span class="failure-text">сквозной связанности</span>:
	   1. Убрать посредника. В таком случае так же не избегаем связанности, но получаем более низкую – предметную. Однако в нашем случае это не выход, т.к. товар сначала резервируется в сервисе *Склад*, далее отправляется через с. *Доставка*, после чего ассортимент снова должен быть обновлен в с. *Склад*. Т.е. избавление от посредника в виде с. *Склад* несет за собой перенос дополнительной логики в с. *Обработчик заказа*, хотя ранее эта логика была сокрыта в более предметном с. *Склад*.![[Сквозная связанность 2.png|450]]
	   2. Можем перенести логику создания *Путевого листа* в с. *Склад*, а ему из с. *Обработчик заказов* будет приходить только необходимая для создания информация. Теперь если с. *Доставка* меняет свой контракт, то это не повлияет на с. *Обработчик заказа*.![[Сквозная зависимость 3.png|500]]
	   3. <span class="warning-text">Использовать общие справочные данные.</span> В таком случае у нас появляется более сильная общая связанность, но учитывая то, что справочные данные **меняются нечасто и доступны только для чтения**, то это позволяет нам более безопасно использовать этот тип связанности.
   5. 