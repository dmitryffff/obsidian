---
tags:
  - книги
  - программирование
  - programming_base
  - javascript
автор: Кайл Симпсон
год: 2024
начал читать: 2024-11-12
закончил читать: 
количество страниц: 332
оценка(0/10): 
прочитал n-раз: 
цена: 1300
---
### Резюме
==Добавьте краткие итоги и свои впечатления о книге. Что нового вы узнали и какие ее особенности?==

### Уточнения
> ***Strict-режим("use strict")*** – режим, который вводит более строгие правила для написания кода:
> 1. В строгом режиме нельзя присваивать неинициализированные переменные.
> 2. Нельзя использовать зарезервированные(class, eval и т.п.) имена.
> 3. Нельзя дублировать параметры функций. `function myFunction(a, a, b) {`
> 4. Запрет на `this` в глобальном контексте. Наприме, `this` в браузере – `window`.
> 5. Нельзя удалять переменные, функции или аргументы, объявленные в строгом режиме.
> 6. Запрет на использование `with`.
> 7. Запрет на изменение `read-only` свойств. ^strict-mode

> ***Принцип минимальных привелегий*** – при проектировании программного продукта(api модуля/объекта) следует предоставлять доступ только к тому, что абсолютно необходимо и "скрывать" все остальное. ^principle-of-least-privilege
## 1. Что такое область видимости?
1. Состояние программы – возможность сохранения и чтения переменных.
2. Область видимости(scope) – набор правил для хранения переменных в определенном месте и их нахождения в будущем.
3. JS является традиционно считается интерпретируемым языком, но на самом деле выполняет JIT(just-in-time) компиляцию часто выполняющихся(вызывающихся) кусков кода для оптимизации. + перед выполнением мы в любом случае делаем микро-компиляции.
4. Процесс компиляции состоит из:
	1. *Лексического анализа/Разбиения на токены* – разбиение последовательности символов на осмысленные с точки зрения языка фрагменты(*токены*). Например: `var a = 2; -> var,a,=,2,;`
	2. *Парсинг* – преобразование массива токенов в [ast(абстрактное синтактическое дерево)](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE). 
	3. *Генерирование кода* – преобразование ast-дерева в исходный исполняемый код.
```js
// Код: var x = 2 + 3
// Представление в виде AST:
{
	type: "VariableDeclaration",
	declarations: [{
		type: "VariableDeclarator",
		id: { type: "Identifier", name: "x" },
		init: {
			type: "BinaryExpression",
			operator: "+",
			left: { type: "Literal", value: 2 },
			right: { type: "Literal", value: 3 }
		}
	}]
}
```
5. Участники выполнения кода:
	1. *Движок*(Д) – отвечает за всю компиляцию и выполнение программы.
	2. *Компилятор*(К) – разбивает на токены и генерирует код.
	3. *Область видимости*(О) – собирает и хранит все идентификаторы, устанавливает строгий набор правил доступа к этим идентификаторам.
	                     ***Как работает `var a = 2;`?***
	1. *К обнаруживает `var a` и обращается к О, чтобы узнать, существует ли такая переменная в наборе конкретной О. Существует – К игнорирует объявление и двагиется дальше. Нет – К обращается к О для объявления этой переменной в наборе этой О.*
	2. *К генерирует код для последующего выполнения Д для обработки присваивания `a = 2`. Код, выполняемый Д, сначала спрашивает у О, есть ли такая переменная с идентификатором `a` в наборе текущей О? Доступна – использует переменную. Нет – идет в другие О.*
	3. *Если Д находит переменную в какой-то из О – присваивает ей значение. Нет – вызывает ошибку.*
6. *LHS-поиск(LeftHand Side)* – поиск переменной(контейнера) в Области видимости для присваивания. *Если при lhs-поиске переменная не была найдена ни в одной области видимости, то если программа не выполняется в [[#^strict-mode|strict-режиме]], то движок "помогает" нам и создает такую переменную в Глобальной области видимости.*
   *RHS-поиск(RightHand Side)* – пытаемся найти значение какой-то переменной в Области видимости.
```js
// выполняем lhs-поиск для присваивания переменной a
var a = 2;
// выполняем rhs-поиск console, пытаемся получить само значение переменной console
// выполняем rhs-поиск значения свойства(метода) log в console
// выполняем rhs-поиск значения переменной a
// выполняем неявное присваивание(lhs-поиск) первому аргументу метода log значения переменной а
console.log(a)
```
7. Могут быть вложенные друг в друга области видимости. Самая верхняя – Глобальна область видитости:
```js
function foo(a) {
    // ...
	// выполняем rhs-поиск b в Области видимости функции foo – не находим, пробуем посмотреть в следующей(Глобальной) области вижимости – находим
	console.log(a + b);
}

var b = 2;
foo(2);
```

## 2. Лексическая область видимости
1. Лексическая области видимости жестко определяется на стадии написания кода и потом(в основном*) не меняется.
   *Определяется на стадии написания кода, т.к. определяется на первой стадии компиляции – лексическом анализе.*
2. *В основном – т.к. есть крайне не рекомендуемые варианты изменить область видимости при помощи `eval('...code')` или `with(obj) {...}`.* :
	1. `eval('...code')` – внутри `eval` компилятор не может знать, что мы хотим определить/изменить, поэтому не пытается "угадать" и пропускает данный код, что ведет к ухудшению производительности.
	2. `with(obj) {...}` – "упрощает" доступ к полям объекта. Под капотом создает ***новую лексическую область видимости***, а т.к. объект может быть любым, то компилятор так же не знает, какой будет лексическая область видимости.
	   *Есть интересный побочный эффект: если свойсва нет в объекте – создает глобальную переменную, а не новое свойсво в объекте, как раз потому, что создается новая область видимости, а если не strict мод, то если не нашли переменную – создаем ее в глобальной области видимости:*
```js
var obj1 = { a: 1 }
var obj2 = { b: 2 }
function foo(obj) {
	with(obj) {
		a = 2
	}
}
foo(o1)
console.log(obj1.a) // 2, все ок, сделали сет нового значения

foo(o2)
console.log(obj2.a) // undefined, свойство так и остается неопределенным
console.log(a) // 2, появляется новая глобальная переменная a
```
3. Области видимости можно представить как пузыри, сложенные друг в друга. Верхний пузырь – Глобальная область видимости. ***Пересечение пузырей обсластей видимости невозможно***
![[Вложенные области видимости.png]]
4. ==Неважно ***где*** вызывается функция и даже ***как*** она вызывается – ее ***лексическая области видимости определяется только тем, где была объявлена функция***==.
## 3. Функциональные и блочные области видимости
1. Все переменные, объявленные в функции, принадлежат этой функции, могут в ней использоваться, а так же использоваться во вложенных функциях.
2. Можно "скрывать" переменные из глобальной области видимости при помощи заключения их в функции. Это позволяет реализовать [[#^principle-of-least-privilege|"Принцип минимальных привилегий"]] и полезно для:
	1. Скрытие приватных деталей работы от их нежелательных изменений функциональности в других местах программы.
	2. Предотвращение конфликтов между одинаковыми именами.
	3. Библиотеки должны скрывать весь свой функционал в пространстве имен библиотеки, обычно, с достаточно уникальным имененем глобального объекта.
	4. Использование модулей позволяет быть уверенным, что библиотеки не будут внедрять свои объекты в глобальную область видимости.
3. ***Функциональное выражение*** – можем определить и вызвать функцию не "загрязняя" глобальную область видимости:
```js
// заключение функции в () означает, что идентификатор foo будет доступен только в теле этой самой функции
(function foo() {
	// здесь foo есть
	var a = 3;
	console.log(a) // 3
})();
// здесь foo уже нет
```
4. ***Анонимное функциональное выражение*** – можем не указывать имя функции, но только в функциональном выражении:
```js
// не указываем имя функции и тут это ОК
setTimeout(function() {
	console.log("Timeout");
}, 1000);
// НЕ в функциональном выражении это ошибка синтаксиса
function() {
	console.log("Timeout");
}
```
*Минусы анонимных функций:*
	1. Не имеют содержательного имени в трассировке стека, что не очень удобно при отладке.
	2. При отсутствии имени сложно обратиться к самому себе для, например, рекурсии; придется использовать устаревший `arguments.callee`.
	3. Нет имении – менее читаемый код.
*Лучше использовать именованные функциональные выражения:*
```js
setTimeout(function timeoutHandler() {
	console.log("Timeout");
}, 1000);
```
5. Немедленно вызывающиееся функциональное выражение(IIFE, "Immediately Invoked Function Expression")
```js
// в первых () объявляем функцию(с именем или без), можно так же обявлять/передавать аргументы
(function foo(b) {
	// здесь foo есть
	var a = 3;
	console.log(a, b) // 3
})(4); // а здесь, вторыми (4) сразу вызываем
// так же можем вызвать так }(4));, функциональность идентична
```
6. ***Блочная область видимости*** – область видимости, ограниченная  фигурными скобками`{...}`.
	1. ***`var`*** в блочной области видимости ***БЕСПОЛЕЗЕН***, т.к. он игнорирует ее(в отличие от функциональной) и все равно создает переменную в Глобальной области видимости.
	2. Конструкция ***`try {} catch (error) {}`*** имеет блочную область видимости, а переменная ***`error` не доступна за пределами блока `catch`***
	3. 
```js
// ---- 1
{
	var a = 2
}
console.log(a) // 2, OK

for (var i = 0; i < 10; i++) {
	console.log(i); // OK
}
console.log(i) // OK

function foo() {
	var c = 1
	console.log(c) // OK
}
console.log(c) // Error
// ----

// ---- 2
try {
	undefined()
} catch(error) {
	console.log(error) // OK
}
console.log(error) // Error
// ----
```
7. ❗️***let***❗️ – ***НАШЕ СПАСЕНИЕ!*** ^let
	1. Неявно прикрепляется к блочной области видимости. Т.е. **блоки для `let` реально работают и позволяют использовать переменную только в блоке.**
	2. При использовании для объявления ***`var`*** мы можем получить ***доступ к переменной из любого места области видимости(выше/ниже объявления)***, в при использовании ***`let`*** мы ***можем обратиться к переменной ТОЛЬКО ПОСЛЕ(ниже) ЕЕ ОБЪЯВЛЕНИЯ.***
```js
// ---- 1
{
	let a = 1
	console.log(a) // 1, OK
}
console.log(a) // Error
// ----

// ---- 2
(function foo() {
	console.log(a) // 1, Ok
	var a = 1
	console.log(a) // 1, Ok
})();

(function foo() {
	console.log(a) // Error
	let a = 1
	console.log(a) // 1, Ok
})();
// ----
```
8. Немного оптимизации при уборке мусора – удаления ненужных, более не используемых переменных:
```js
function process(data) {...}
var veryBigData = {...};
process(veryBigData); // ❗️по сути, после этого шага veryBigData нам не нужна, можно удалить ее и освободить память❗️
// ❗️НО, скорее всего, вижок будет хранить ее дальше❗️

// ...другой код

// ------------

function process(data) {...}

// ❗️явно показываем движку, что ограничиваем переменную veryBigData блочной областью видимости и после исплнения этого блока кода мы не смодем ее испольховать => можно удалить❗️
{
	let veryBigData = {...};
	process(veryBigData);
}

// ...другой код
```
9. В цикле `for`  `let` связывается с блочной областью видимости `for` ПРИ КАЖДОЙ ИТЕРАЦИИ:
```js
{
	let j;
	for (j = 0; j < 10; j++) {
		let i = j; // связывает заново при каждой итерации 
		console.log(i)
	}
}
```
10. ***`const`*** – как [[#^let|let]], но создает константу – ***незименяемую переменную***.

## 4. Поднятие
1. Объявления переменных(*но не присваивание им значений!*) всегда происходит перед началом выполнения кода:
```js
// код на сомом деле
console.log(a); // undefined, а не ошибка ReferenceError и не 2
var a = 2;

// потому что, компилятор превращает код в такое
var a;
console.log(a); // undefined
a = 2;
```
2. Это **перемещение объявления переменных и функций называется *поднятием(hoisting)***.
3. Поднятие функций работает так – ***сначала поднимаются ФУНКЦИИ***, потом уже переменные:
```js
// код на сомом деле
foo(); // 1, не ReferenceErorr и не TypeError, foo тут не undefined

var foo;

function foo() {
	console.log(1);
}

foo = function() {
	console.log(2);
}
foo() // 2

// компилятор превращает код в такое
function foo() {
	console.log(1);
}
// ❗️Важно заметить, что `var foo;` вообще игнорируется, как дублирующее объявление переменной❗️

foo(); // 1

foo = function() {
	console.log(2);
}
foo() // 2
```
Важно заметить❗️, что ***повторные объявления функций будут переопределять предыдущие!***:
```js
foo() // 3

function foo() {
	console.log(1);
}

foo = function() {
	console.log(2);
}

// переопределяем предудыщее объявление `function foo()` этим
function foo() {
	console.log(3);
}
```
4. ***Объявления функции поднимается, функционального выражения – нет***
```js
foo(); // не ReferenceError, но TypeError(undefined is not a function)
var foo = function bar() {...}

// ❗️Важно отметить, что имя функции в функциональном выражении `bar` никак не влияет❗️
bar(); // ReferenceErorr
```
5. Функции поднимаются из блочной области видимости:
```js
foo(); // "b"
var a = true;
if (a) {
	// поднимается из условной блочной области видимости
	function foo() {
		console.log("a")
	}
} else {
	// ❗️поднимается из условной блочной области видимости И переопределяет предыдущее объявление `foo`❗️
	function foo() {
		console.log("b")
	}
}
```

## 5. Замыкание области видимости
1. фыв