[Схемы](https://app.diagrams.net/#G1UJt4xv9QZYIfyRWlJfuAsCnT4tj-gDg7#%7B%22pageId%22%3A%22IMx9VPlgQBP8EnmAfyif%22%7D)
> ***Микросервисы*** – подход к распределенным системам, при котором используются небольшие сервисы, каждый из которых можно независимо друг от друга разрабатывать, тестировать, выпускать.
> 
> ***Монолит*** – когда все функциональные возможности приложения должны развертываться вместе.

>[!info]
>**Связанность(coupling)** – зависимость кода друг от друга. Т.е. при изменении функциональность в одном месте необходимо менять функциональность в другом. *<span class="failure-text">Высокая связанность</span>* - высокая зависимость, *<span class="success-text">низкая связанность</span>* - низкая зависимость. ^coupling

>[!info]
>**Связность(cohesion)** – логическая связанность между частями модуля(программы). Т.е. все части внутри модуля имеют определенную четкую роль и способствуют достижению цели этого модуля. ^cohesion
# Часть 1 – Основы
## Глава 1 – Что такое микросервисы?
1. Микросервисы моделируются вокруг предметной области бизнеса, инкапсулирует функциональность и делает ее доступной при помощи сетей.
2. Чаще всего не используются общие базы данных, т.е. **для каждого сервиса отдельная бд.**
3. В микросервисах отдаем приоритет сильной [[#^cohesion|связности]] бизнес-функциональности, а не технической функциональности.
4. **Необходимо избегать использования общих баз данных.**
5. Про размеры:
	1. Микросервис должен быть такого размера, чтобы его можно было легко понять;
	2. “*Микросервис должен быть размером с вашу голову”* – Джеймс Льюис;
	3. **В начале работы лучше не беспокоиться о размере микросервиса.**
7. Разделение команды:
	1. Компании создают проекты, коммуникация в которых происходит так же, как и коммуникация в компании, т.е. если внутри компании есть девопс-инженеры, бэкенд-разработчики и фронтенд-разработчики, то и сам проект будет состоять из таких же 3-х частей. В итоге, проект будет выглядеть так, а внесение изменений(в большинстве случаев) потребует затрагивания всех трех слоев:
	   ![[Pasted image 20240509165336.png]]
	2. Если мы хотим упростить способ внесения изменений – нужно пересмотреть способ группировки кода, выбрав связность бизнес-функциональности, а не технологий:
	   ![[Pasted image 20240509165648.png]]
7. Виды монолитных архитектур:
	1. Однопроцессорный монолит - система, весь код которой развертывается как единый процесс. Самый простой, одна программа, одна бд(может и не одна, но единые для программы в целом). С ростом команды растет и монолит.
	2. Модульный монолит – подмножество однопроцессорного, в котором код разделен на несколько модулей, а бд одна. Для развертывания модули все равно необходимо соединить. Неплохой вариант для параллельной работы команд, если правильно определить границы модулей.
	3. Распределенный монолит – состоящая из нескольких сервисов система, которую необходимо деплоить единовременно. Плохой вариант. Обладает недостатками и монолитной, и микросервисной архитектур.
8. **Монолит стоит рассматривать как решение по умолчанию. Т.е. “*назовите мне убедительную причину использовать микросервисы*“.**
9. Аггрегация логов очень важна(а в микросервисах еще и нетривиальна). Инструмент для аггрегации стоит рассматривать как обязательный.
10. ***“…сделайте все возможное, чтобы кто-то другой управлял кластером Kubernetes вместо вас"**, пусть даже и с использованием управляющего сервиса от облачного провайдера. Запуск собственного кластера может потребовать значительного объема работ!“*
11. Бессерверный подход – когда не думаем о количество используемых компьютеров, а просто запускаем код. Сервис сам масштабирует ресурсы по мере необходимости. Пример – *функция как услуга(FaaS, function as a service)(Firebase).*
12. <span class="success-text">Преимущества микросервисов:</span>
	1. Технологическая неоднородность – т.к. мы скрываем информацию внутри микросервиса, предоставляя только внешнее api, а так же из-за того, что наш микросервис – отдельный, не связанный с другими модуль, мы можем использовать различный технологии(языки, фреймворки).
	2. Надежность – выход из строя одного сервиса не повлияет на работоспособность всей программы, только может только на какие-то связанные. Но для этого нужно организовать перебор(bulkhead) микросервисов(периодически пингуем микросервисы), чтобы вовремя обнаружить вышедшие из строя. НО у нас появляется новый источник ошибок – СЕТИ. **СЕТИ МОГУТ И БУДУТ ЛОМАТЬСЯ**.
	3. Масштабирование – при монолитной архитектуре если нам не хватает мощности придется масштабировать весь монолит. В микросервисной архитектуре можно масштабировать только отдельные микросервисы.
	4. Простое развертывание – при небольших изменениях в большом монолите нам придется деплоить веееесь монолит, при небольших изменениях в небольшом микросервисе придется деплоить только этот микросервис.
	5. Согласованность рабочих процессов – сотрудники в больших компаниях могут делиться на небольшие команды со своими зонами ответственности, что улучшает продуктивность.
	6. Можем использовать одни и те же микросервисы по-разному, в зависимости от того, кто и откуда обращается.
13. <span class="failure-text">Недостатки микросервисов:</span>
	1. Опыт разработчика.
	2. Технологическая перегрузка – микросервисы сами по себе тащат за собой большое количество дополнительных инструментов для эффективной работы с ними, а тут еще и у нас распускаются руки в выборе технологий для реализации микросервисов, что может повлечь большую неоднородность технологий. Нужно не переусердствовать с этим.
	3. Стоимость – микросервисы имеют свою цену, т.к. на построение такой архитектуры требуется больше времени и других ресурсов.
	4. Отчетность – у нас распределенная системы, у каждого микросервиса своя бд => **сложности аггрегацией данных для их анализа.** Решать пытаются при помощи *потоковой передачи данных, можно так же сливать все данные из разных бд в единую(или озера данных).*
	5. Мониторинг и устранение неполадок.
	6. Безопасность – у нас появляется взаимодействие между микросервисами по сети, которая имеет свои уязвимости.
	7. Тестирование.
	8. Время ожидания – теперь мы взаимодействуем не в рамках одного процесса, как в монолитной архитектуре, а между различными сервисами, в процессе общения которых происходят постоянные серилизация/десериализация данных и другие накладные процессы, которые могут снизить общий отклик системы.
	9. Согласованность данных – теперь вместо одной бд у нас их несколько и нам следует внимательно следить за тем, чтобы данные были полные и валидные.
14. Кому подойдут микросервисы – для больших команд с устоявшимися предметными областями.
15. Кому НЕ подойду микросервисы – небольшим командам, стартапам, командам с неустоявшейся предметной областью, т.к. повлекут только дополнительные расходы на реализацию и поддержку микросервисной архитектуры.
## Как моделировать микросервисы